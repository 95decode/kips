---
kip: 82
title: A new GC reward structure due to abolition of the Gini coefficient
author: Yeri<yeriel.lee@krustuniverse.com>, Daniel<daniel.cc@krustuniverse.com>, Aidan<aidan.kwon@krustuniverse.com>, Ollie<ollie.j@krustuniverse.com>, Sam<sam.seo@krustuniverse.com>, Uno<uno.lee@krustuniverse.com>, Eddie<eddie.kim0@krustuniverse.com>
discussion-to: https://govforum.klaytn.foundation/t/proposal-a-new-gc-reward-structure-to-abolition-of-the-gini-coefficient/21
status: Draft
type: Standards Track
category: Core
created: 2022-09-21
---


## Simple Summary
A renewal of the Governance Council(GC) reward structure due to abolition of the Gini coefficient.

## Abstract
In addition to traditional enterprises, Klaytn is expanding the Governance Council (GC) by bringing DAOs in response to the growth of nontraditional entities. Such a change in the GC ecosystem will restructure the entire Klaytn governance structure. Abolishing the current block proposal selection method based on the Gini coefficient and staking quantity, the new reward program alleviates the problem of providing insufficient compensation for the network contribution and block verification due to lack of staking. The instability of certain nodes with high staking amounts can result in poor network stability as a whole. The renewed structure enables to reward the staking amount regardless of block miner by providing 20% total rewards for block generation and 80% based on staking amount. This form is to reward the participants for providing network stability with node operation and financial contribution.

## Motivation
Klaytn has been compensating GC with block creation rewards based on the quantity of staking and the Gini coefficient. This included rewards incurred by minting and gas fee rewards generated by transactions during block creation. As mentioned in the [Klaytn 2.0 Lightpaper](https://klaytn.foundation/wp-content/uploads/Lightpaper.pdf), Klaytn is abolishing the Gini coefficient since this measure demotivates members from staking. Discontinuation of the Gini coefficient increases the risk to network stability due to the expanding reliance on certain nodes. This change ultimately calls for the revision of block proposer selection and reward structure. In an effort to enhance individual voting power and promote ultimate decentralization, we aim to accomplish the following changes:
- Ameliorate the risk that block creation depends on larger staker nodes
- Associate GC reward with the growth of the Klaytn ecosystem

## Specification
Block generation is rewarded for the node operations that are serving as public goods in the Klaytn network. CN and PN are in charge of block creation and propagation while EN is in charge of blockchain data inquiry based on an individual's needs. The infrastructure cost remains similar, enabling some fixed benefits. Therefore, fixed compensation will be equivalent to the sum of the transaction fee and an additional block compensation, which can be both inflationary and deflationary.

The block proposal method will be based on equal selection regardless of the staking amount. The current model provides a block generation reward based on staking amount and the Gini-coefficient. Until now, the Gini coefficient was utilized to alleviate the chance of an entity with more staking amount being selected as a block proposer. As this model provided a fairly equal chance to every participant, each node was promised a certain amount of rewards.

In the new method, the reward for node operation is required since the staking amount is not considered in the proposal selection process. Therefore, 20 percent of the total reward amount will be placed as a node operation reward.

Node operators will also be compensated with the staking for enhancing network stability from an economic standpoint. The opportunity cost incurred from staking is rewarded based on inflation. In this system, inflation provides a tax-like common effect. Public users can also participate and receive rewards through the GC-run public staking program.

As of September 21st, 2022, of the 300 million KLAY that is minted annually, only 100 million KLAY goes to GC, and 20% and 80% of the distribution is from this 100 million KLAY. The renewal separates GC reward into two groups: basic reward and staked reward. The basic reward is compensating for node operation by providing 20% of GC reward and 100% of gas fee resources from transactions. The staked reward provides only the rest of 80% of the minting resource based on the total stake amount.

![gc reward allocation](../assets/kip-82/gc_reward_allocation.png)

After the Magma hard fork, Klaytn has been burning the first half of the gas fee based on the KIP-71 proposal while the second half is distributed. The remaining second half is distributed into GC reward, Klaytn Improvement Reserve (KIR) and Klaytn Growth Fund (KGF).

The renewal will include a change of gas fee as follows.

In addition to changing the reward structure, this renewal will include burning the gas fee that is provided as GCâ€™s basic reward. The KGF and KIR portion will be excluded from the gas fee.
If the amount of gas fee that is provided as a basic reward does not exceed a certain level, all of them will be burned. The threshold amount is 20% of minting provided as a basic reward. If the gas fee exceeds this amount, 20% will be incinerated and the additional amount will be distributed to GC.

To reduce the KLAY supply amount due to inflation, the gas fee will be burned.

### Klaytn node update

The Klaytn node will be updated according to the new reward policy. The CN portion is further splitted into basic reward and staked reward. The staked reward is then distributed among CNs proportional to their staking shares. Their shares are calculated proportionally to their stake amounts except for the minimum staking amount.

During integer arithmetics, minuscule remaining amounts may be emitted as by-products. Such remaining amounts will be added to the KGF portion. Below pseudocode illustrates the new reward distribution algorithm. Note: // is integer division, round down.

```python
from collections import defaultdict

MAGMA_BLOCK_NUMBER = 99841497
FORK_BLOCK_NUMBER = 120000000 # TBD

# Block header. Only relevant fields are shown here.
class Header:
    Number: int = 0   # Block number
    GasUsed: int = 0  # Total gas spent in the block
    BaseFee: int = 0  # Base fee per gas at the block
    RewardBase: string = "" # Reward recipient address of the block proposer

# Network configurations related to reward distribution.
# Corresponds to Klaytn's reward.rewardConfig struct.
class RewardConfig:
    UnitPrice: int = 25000000000              # "governance.unitprice" parameter (in peb)
    MintingAmount: int = 9600000000000000000  # "reward.mintingamount" parameter (in peb)
    MinimumStake: int = 5000000               # "reward.minimumstake" parameter (in KLAY)
    DeferredTxFee: bool = true    # "reward.deferredtxfee" parameter
    UseKIP82: bool = true         # "reward.usekip82" parameter (new)

    # "reward.ratio" parameter (e.g. "34/54/12")
    CnRatio: int = 34
    KgfRatio: int = 54
    KirRatio: int = 12
    TotalRatio: int = CnRatio + KgfRatio + KirRatio

    # "reward.kip82ratio" parameter (e.g. "20/80") (new)
    CnMintedBasicRatio: int = 20
    CnMintedStakeRatio: int = 80
    CnMintedTotalRatio: int = CnMintedBasicRatio + CnMintedStakeRatio

# CN staking status and KGF/KIR addresses.
# Corresponds to Klaytn's reward.StakingInfo struct.
class StakingInfo:
    KIRAddr: string = ""
    KGFAddr: string = ""
    Nodes: List[ConsolidatedNode] = []

# Staking information merged under the same CN.
# Sometimes a node would register multiple NodeAddrs
# in which each entry has different StakingAddr and the same RewardAddr.
# We treat those entries with common RewardAddr as one node.
# Corresponds to Klaytn's reward.ConsolidatedNode struct.
class ConsolidatedNode:
    NodeAddrs: List[string] = []
    StakingAddrs: List[string] = []
    RewardAddr: string = "" # The common reward address of the CN
    StakingAmount: int = 0  # Total staking amount across StakingAddrs (in KLAY)

# Reward disribution details.
class RewardSpec:
    Minted: int = 0   # The amount minted
    Fee: int = 0      # Total tx fee spent
    Burnt: int = 0    # The amount burnt
    Proposer: int = 0    # The amount allocated to the block proposer
    Stakers: int = 0  # Total amount allocated to stakers
    Kgf: int = 0      # The amount allocated to KGF
    Kir: int = 0      # The amount allocated to KIR
    Rewards: Dict[string, int] = {}  # Mapping from reward recipient to amounts

# Distributes a given block's reward to CNs and KGF/KIR funds.
# corresponds to Klaytn's reward.RewardDistributor.DistributeBlockReward().
#
# - state is the StateDB to apply the rewards.
# - header is a Header instance.
# - config is a RewardConfig instance.
# - staking_info is a StakingInfo instance.
def distribute_block_reward(state, header, config, staking_info):
    spec = calc_deferred_reward(header, config, staking_info)

    for addr, amount in spec.Rewrads:
        state.AddBalance(addr, amount)

# Calculates the deferred rewards, which are determined at the end of block processing.
# Used in reward distribution.
# Returns a RewardSpec.
def calc_deferred_reward(header, config, staking_info):
    minted = config.MintingAmount
    fee, burnt = calc_fee_resource(header, config)

    proposer, stakers, kgf, kir, split_rem = split_reward(header, config, minted, fee)
    shares, share_rem = calc_stake_shares(config, staking_info, stakers)

    kgf += split_rem
    kgf += share_rem

    spec = RewardSpec()
    spec.Minted = minted
    spec.Fee = fee
    spec.Burnt = burnt
    spec.Proposer = proposer
    spec.Stakers = stakers
    spec.Kgf = kgf
    spec.Kir = kir

    spec.Rewards = defaultdict(int)
    spec.Rewards[header.RewardBase] += proposer
    # If KGF address is not set, proposer gets the portion.
    if staking_info.KGFAddr is None:
        spec.Rewards[header.RewardBase] += kgf
    else:
        spec.Rewards[staking_info.KGFAddr] += kgf
    # If KIR address is not set, proposer gets the portion.
    if staking_info.KIRAddr is None:
        spec.Rewards[header.RewardBase] += kir
    else:
        spec.Rewards[staking_info.KIRAddr] += kir

    for reward_addr, reward_amount in shares:
        spec.Rewards[reward_addr] += reward_amount
    return spec

# Returns (fee, burnt_fee)
def calc_fee_resource(header, config):
    # If not DeferredTxFee, fees are already added to the proposer during TX execution,
    # therefore no fees to distribute here at the end of block processing.
    if not config.DeferredTxFee:
        return (0, 0)

    # Start with total block gas fee
    if header.Number >= MAGMA_BLOCK_NUMBER:
        fee = header.GasUsed * header.BaseFee
    else:
        fee = header.GasUsed * config.UnitPrice

    burnt = 0

    # Since Magma, burn half of gas
    if header.number >= MAGMA_BLOCK_NUMBER:
        half_fee = fee / 2
        fee -= half_fee
        burnt += half_fee

    # If KIP-82 is enabled, burn fees up to BasicReward
    if header.number >= FORK_BLOCK_NUMBER and config.UseKIP82:
        minted = config.MintingAmount
        cn_minted = minted * config.CnRatio // config.TotalRatio
        basic_reward = cn_minted * config.CnMintedBasicRatio // config.CnMintedTotalRatio
        if fee < basic_reward:
            burnt_kip82 = fee
        else:
            burnt_kip82 = basic_reward

        fee -= burnt_kip82
        burnt += burnt_kip82

    return (fee, burnt)

# Returns (proposer, stakers, kgf, kir, remaining) amounts
def split_reward(header, config, minted, fee):
    if header.number >= FORK_BLOCK_NUMBER and config.UseKIP82:
        resource = minted

        cn = resource * config.CnRatio // config.TotalRatio
        kgf = resource * config.KgfRatio // config.TotalRatio
        kir = resource * config.KirRatio // config.TotalRatio

        cn_basic = cn * config.CnMintedBasicRatio // config.CnMintedTotalRatio
        cn_stake = cn * config.CnMintedStakeRatio // config.CnMintedTotalRatio

        remaining = resource - kgf - kir - cn_basic - cn_stake
        return (cn_basic + fee, cn_stake, kgf, kir, remaining)
    else:
        resource = minted + fee

        cn = resource * config.CnRatio // config.TotalRatio
        kgf = resource * config.KgfRatio // config.TotalRatio
        kir = resource * config.KirRatio // config.TotalRatio

        remaining = resource - kgf - kir - cn
        return (cn, 0, kgf, kir, remaining)

# Distribute stake_reward among staked CNs
# Returns a mapping from each reward address to their reward shares,
# and remaining amount.
def calc_stake_shares(config, staking_info, stake_reward):
    if stake_reward == 0:
        return ({}, 0)

    min_stake = config.MinimumStake * 1e18
    total_stakes = 0
    for node in staking_info.Nodes:
        if node.StakingAmount > min_stake:
            total_stakes += (node.StakingAmount - config.MinimumStake)

    shares = {}
    remaining = stake_reward
    for node in staking_info.Nodes:
        if node.StakingAmount > min_stake:
            effective_stake = node.StakingAmount - min_stake
            reward_amount = stake_reward * effective_stake // total_stakes
            remaining -= reward_amount
            shares[node.RewardAddr] = reward_amount

    return (shares, remaining)

# Unlike calc_deferred_reward, this function calculates the actual reward amounts
# paid in this block. Used in klay_getReward RPC
# Retruns a RewardSpec.
def calc_actual_reward(header, config, staking_info):
    spec = calc_deferred_reward(header, config, staking_info)

    # If not DeferredTxFee, include block gas fee because they were ignored in
    # calc_deferred_reward.
    if not config.DeferredTxFee:
        if header.number >= MAGMA_BLOCK_NUMBER:
            block_fee += header.GasUsed * header.BaseFee
        else:
            block_fee += header.GasUsed * config.UnitPrice
        spec.Proposer += block_fee
        spec.Rewards[header.RewardBase] += block_fee

    return spec
```

The update is expected to increase the amount of per-block state changes by number of GCs. The increase should be reasonable since the amount is significantly smaller than Klaytn's transaction processing capability.

### Reward RPC

A new JSON-RPC method is added to provide historic reward distribution details.

- Name: `klay_getRewards`
- Description: Returns allocation details of reward distribution at specified block. If the parameter is not set, returns a breakdown of reward distribution at the lastest block.
- Parameters
  1. `QUANTITY | TAG` - (optional) integer or hexadecimal block number, or the string "earlist" or "latest".
- Returns
  - `DATA`
    - `source`
      - `minted`: The amount minted
      - `fee`: Total tx fee spent
      - `burnt`: The amount burnt
    - `output`
      - `proposer`: The amount block proposer receives
      - `stakers`: Total amount stakers receive
      - `kgf`: The amount KGF receives
      - `kir`: The amount KIR receives
    - `rewards`: A mapping from reward recipient address to reward amount
- Example
  ```
  // Request
  curl -X POST -H "Content-Type: application/json" --data '{"jsonrpc":"2.0", "method":"klay_getRewards", "params":["0x5f5e100"],"id":1}' https://api.baobab.klaytn.net:8651
  // Response
  {
    "jsonrpc":"2.0",
    "id":1,
    "result":{
      "source": {
        "minted": "9600000000000000000",
        "fee": "4616950000000000",
        "burnt": "2308475000000000",
      },
      "output": {
        "proposer": "3264784881500000000",
        "stakers": "0",
        "kgf": "5185246576500000000",
        "kir": "1152277017000000000"
      },
      "rewards": {
        "0x99fb17d324fa0e07f23b49d09028ac0919414db6": "3264784881500000000",
        "0x2bcf9d3e4a846015e7e3152a614c684de16f37c6": "5185246576500000000",
        "0x716f89d9bc333286c79db4ebb05516897c8d208a": "1152277017000000000"
      }
    }
  }
  ```

## Expected Effect
The proposed GC reward mechanism is expected to produce the following changes:
- GC members increase individual staking amount.
- The higher number of KLAY holders receive profit from staking.
- Total Value Locked (TVL) of Klaytn increases.
- The total circulation reduces.

## Backward Compatibility
Klaytn nodes must be upgraded before FORK_BLOCK_NUMBER to correctly produce or verify blocks.

## Reference
n/a

## Copyright
Copyright and related rights waived via CC0<https://creativecommons.org/publicdomain/zero/1.0/>.
